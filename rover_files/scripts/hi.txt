thor.py 

import time
import os
import cv2
import pytesseract
from datetime import datetime
from dronekit import connect, VehicleMode
from model_loader import ModelLoader
from model_inference import ModelInference
from database import Database
from yaw import get_yaw, adjust_steering_for_yaw
import math
import re
import rover_telemetry

# --- Configuration ---
SERIAL_PORTS = ['/dev/ttyUSB0', 'COM3']
BAUD_RATE = 57600
THROTTLE_CH = 3
STEERING_CH = 1
CENTER = 1500
THROTTLE_NEUTRAL = 1500
THROTTLE_MAX = 2000
DURATION = 20  # seconds
honey = 0.3
MAX_SPEED_MPS = 1.0
OUTPUT_DIR = os.path.dirname(os.path.abspath(__file__))
CAR_MODEL = '../models/car.onnx'
NP_MODEL = '../models//np.onnx'
SLOT_SIZE = 2.0  # meters per slot

def correct_by_position(ocr_str):
    ocr_str = re.sub(r'[^A-Za-z0-9]', '', ocr_str).upper()
    digit_to_alpha = {'0': 'O', '1': 'I', '2': 'Z', '4': 'A', '5': 'S', '8': 'B', '6': 'G'}
    alpha_to_digit = {'O': '0', 'I': '1', 'Z': '2', 'S': '5', 'B': '8', 'G': '6', 'Q': '0', 'L': '1', 'E': '6', 'J': '3', ']': '3'}
    letters = []
    digits = []
    i = 0
    while len(letters) < 2 and i < len(ocr_str):
        ch = ocr_str[i]
        if ch.isalpha():
            letters.append(ch)
        elif ch in digit_to_alpha:
            letters.append(digit_to_alpha[ch])
        i += 1
    while len(digits) < 2 and i < len(ocr_str):
        ch = ocr_str[i]
        if ch.isdigit():
            digits.append(ch)
        elif ch in alpha_to_digit:
            digits.append(alpha_to_digit[ch])
        i += 1
    if len(ocr_str) == 10:
        while len(letters) < 4 and i < len(ocr_str):
            ch = ocr_str[i]
            if ch.isalpha():
                letters.append(ch)
            elif ch in digit_to_alpha:
                letters.append(digit_to_alpha[ch])
            i += 1
    elif len(ocr_str) == 9:
        while len(letters) < 3 and i < len(ocr_str):
            ch = ocr_str[i]
            if ch.isalpha():
                letters.append(ch)
            elif ch in digit_to_alpha:
                letters.append(digit_to_alpha[ch])
            i += 1
    while len(digits) < 6 and i < len(ocr_str):
        ch = ocr_str[i]
        if ch.isdigit():
            digits.append(ch)
        elif ch in alpha_to_digit:
            digits.append(alpha_to_digit[ch])
        i += 1
    if len(letters) < 3 or len(digits) < 6:
        return "Could not parse correctly"
    part1 = ''.join(letters[:2])
    part2 = ''.join(digits[:2])
    part3 = ''.join(letters[2:4])
    part4 = ''.join(digits[2:6])
    return part1 + part2 + part3 + part4

def send_rc(vehicle, throttle, steering):
    vehicle.channels.overrides = {THROTTLE_CH: throttle, STEERING_CH: steering}
    print(f"[DEBUG] RC override -> Throttle: {throttle}, Steering: {steering}")

def connect_vehicle():
    for port in SERIAL_PORTS:
        try:
            v = connect(port, baud=BAUD_RATE, wait_ready=False)
            print(f"[DEBUG] Connected to vehicle on {port}")
            return v
        except Exception as e:
            print(f"[DEBUG] Failed to connect on {port}: {e}")
    raise RuntimeError("Unable to connect to any Pixhawk port.")

def arm_and_manual(vehicle):
    print("[DEBUG] Performing pre-arm checks...")
    timeout = time.time() + 10
    while not vehicle.is_armable and time.time() < timeout:
        fix = getattr(vehicle.gps_0, 'fix_type', 'N/A')
        sats = getattr(vehicle.gps_0, 'satellites_visible', 'N/A')
        volt = getattr(vehicle.battery, 'voltage', 'N/A')
        print(f"  [DEBUG] Waiting: GPS fix {fix}, sats {sats}, battery {volt}V")
        time.sleep(1)
    if not vehicle.is_armable:
        print("[DEBUG] Warning: Vehicle not armable. Proceeding without arming.")
    else:
        vehicle.armed = True
        while not vehicle.armed and time.time() < timeout:
            print("  [DEBUG] Waiting for arming...")
            time.sleep(1)
        vehicle.mode = VehicleMode('MANUAL')
        mtimeout = time.time() + 10
        while vehicle.mode.name != 'MANUAL' and time.time() < mtimeout:
            print(f"  [DEBUG] Switching mode: current {vehicle.mode.name}")
            vehicle.mode = VehicleMode('MANUAL')
            time.sleep(1)
        print(f"[DEBUG] Armed: {vehicle.armed}, Mode: {vehicle.mode.name}")

def preprocess_plate(plate_img):
    gray = cv2.cvtColor(plate_img, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (3, 3), 0)
    _, binary = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return binary

def get_slot_number(distance):
    slot_num = math.floor(distance / SLOT_SIZE) + 1
    return f"A{slot_num}"

def main():
    cap = None
    vehicle = None
    db = None
    start_time = None
    num_frames = 0
    car_count = 0
    plate_count = 0
    plate_texts = []
    plate_image_paths = []
    cumulative_distance = 0.0

    try:
        db = Database()
        vehicle = connect_vehicle()
        arm_and_manual(vehicle)
        initial_yaw = get_yaw(vehicle)
        if initial_yaw is None:
            print("Warning: Initial yaw unavailable. Yaw correction will not be applied.")
            drift_threshold = None
        else:
            drift_threshold = 2

        cap = cv2.VideoCapture(0)
        if not cap.isOpened():
            print("[DEBUG] Cannot open webcam at index 0. Trying index 1...")
            cap = cv2.VideoCapture(1)
            if not cap.isOpened():
                print("[ERROR] Cannot open webcam at index 1. Ensure a webcam is connected.")
                return

        print("[DEBUG] Webcam connected. Loading models...")
        loader = ModelLoader(CAR_MODEL, NP_MODEL)
        inference = ModelInference(loader)

        throttle_val = int(THROTTLE_NEUTRAL + (THROTTLE_MAX - THROTTLE_NEUTRAL) * honey)
        speed_factor = (throttle_val - THROTTLE_NEUTRAL) / float(THROTTLE_MAX - THROTTLE_NEUTRAL)
        print(f"[DEBUG] Speed factor set to {speed_factor:.2f}")

        send_rc(vehicle, throttle_val, CENTER)
        start_time = time.time()
        last_time = start_time
        print("[DEBUG] Entering main loop...")

        while time.time() - start_time < DURATION:
            try:
                ret, frame = cap.read()
                if not ret:
                    print("[DEBUG] Frame read failed; skipping.")
                    continue

                current_time = time.time()
                dt = current_time - last_time
                last_time = current_time
                distance_increment = speed_factor * MAX_SPEED_MPS * dt
                cumulative_distance += distance_increment
                slot = get_slot_number(cumulative_distance)

                num_frames += 1
                ts = datetime.now().strftime('%Y%m%d_%H%M%S_%f')[:-3]
                print(f"\n[DEBUG] Frame #{num_frames} @ {ts} | +{distance_increment:.3f}m -> Slot {slot}")

                raw_fp = os.path.join(OUTPUT_DIR, f"frame_{ts}.jpg")
                cv2.imwrite(raw_fp, frame)
                print(f"[DEBUG] Saved raw frame: {raw_fp}")

                vis_fp = os.path.join(OUTPUT_DIR, f"vis_{ts}.jpg")
                cars, cscores, cids, plates, pscores, pids = inference.infer(raw_fp, vis_fp)
                print(f"[DEBUG] Detected {len(cars)} cars, {len(plates)} plates")

                # Process car crops
                try:
                    if len(cars) > 0:
                        height, width = frame.shape[:2]
                        for i, (x1, y1, x2, y2) in enumerate(cars):
                            print(f"[DEBUG] Car {i} bbox: ({x1:.1f},{y1:.1f})→({x2:.1f},{y2:.1f})")
                            x1 = max(0, int(x1))
                            y1 = max(0, int(y1))
                            x2 = min(width, int(x2))
                            y2 = min(height, int(y2))
                            if x2 > x1 and y2 > y1:
                                crop = frame[y1:y2, x1:x2]
                                if not crop.size == 0:
                                    cf = os.path.join(OUTPUT_DIR, f"car_{ts}_{i}.jpg")
                                    cv2.imwrite(cf, crop)
                                    print(f"[DEBUG] Saved car crop: {cf}")
                                    car_count += 1
                                else:
                                    print(f"[DEBUG] Skipped car {i} crop: empty image")
                            else:
                                print(f"[DEBUG] Skipped car {i} crop: invalid bbox")
                except Exception as car_err:
                    print(f"[ERROR] Car crop processing error: {car_err}")

                # Process plate crops + OCR
                try:
                    if len(plates) > 0:
                        height, width = frame.shape[:2]
                        for j, (x1, y1, x2, y2) in enumerate(plates):
                            print(f"[DEBUG] Plate {j} bbox: ({x1:.1f},{y1:.1f})→({x2:.1f},{y2:.1f})")
                            x1 = max(0, int(x1))
                            y1 = max(0, int(y1))
                            x2 = min(width, int(x2))
                            y2 = min(height, int(y2))
                            if x2 > x1 and y2 > y1:
                                crop = frame[y1:y2, x1:x2]
                                if not crop.size == 0:
                                    pf = os.path.join(OUTPUT_DIR, f"plate_{ts}_{j}.jpg")
                                    cv2.imwrite(pf, crop)
                                    plate_image_paths.append(pf)
                                    plate_count += 1
                                    print(f"[DEBUG] Saved plate crop: {pf}")

                                    processed = preprocess_plate(crop)
                                    text = pytesseract.image_to_string(processed, config='--psm 7').strip()
                                    print(f"[DEBUG] Raw OCR output: '{text}'")
                                    if text:
                                        corrected_text = correct_by_position(text)
                                        print(f"[DEBUG] Corrected OCR output: '{corrected_text}'")
                                        if corrected_text != "Could not parse correctly":
                                            plate_texts.append(f"{corrected_text} (Pending, Slot {slot})")
                                            if db:
                                                db.log_car_entry(corrected_text, slot)
                                                db.upsert_number_plate(corrected_text, slot)
                                        else:
                                            print("[DEBUG] OCR correction failed: Could not parse correctly")
                                            plate_texts.append(f"{text} (Parse Failed, Slot {slot})")
                                    else:
                                        print("[DEBUG] No text extracted.")
                                        plate_texts.append(f"No text extracted (Slot {slot})")
                                else:
                                    print(f"[DEBUG] Skipped plate {j} crop: empty image")
                            else:
                                print(f"[DEBUG] Skipped plate {j} crop: invalid bbox")
                except Exception as plate_err:
                    print(f"[ERROR] Plate processing error: {plate_err}")

                if drift_threshold is not None:
                    steering = adjust_steering_for_yaw(vehicle, initial_yaw, drift_threshold)
                else:
                    steering = CENTER
                send_rc(vehicle, throttle_val, steering)
                time.sleep(0.05)

            except Exception as frame_err:
                print(f"[ERROR] Frame #{num_frames} processing error: {frame_err}")

        print("\n[DEBUG] Movement duration ended; stopping rover...")
        for _ in range(5):
            send_rc(vehicle, THROTTLE_NEUTRAL, CENTER)
            time.sleep(0.2)
        vehicle.channels.overrides = {}

    except Exception as e:
        print(f"[ERROR] Setup/main loop failure: {e}")

    finally:
        # Log telemetry data once after main loop
        if vehicle and db:
            try:
                print("[DEBUG] Logging final telemetry data...")
                rover_telemetry.log_telemetry_once(vehicle, db)
            except Exception as telemetry_err:
                print(f"[ERROR] Telemetry logging error: {telemetry_err}")

        # Clean up resources
        if cap:
            cap.release()
        if vehicle:
            try:
                vehicle.close()
            except:
                pass
        if db:
            db.close()
        print("[DEBUG] Resources cleaned up.")

        if start_time is not None:
            elapsed = time.time() - start_time
            fps = num_frames / elapsed if elapsed > 0 else 0.0
            final_slot = get_slot_number(cumulative_distance)
            print("\n=== Final Detection Summary ===")
            print(f"Frames processed:       {num_frames}")
            print(f"Overall FPS:           {fps:.2f}")
            print(f"Total cars detected:   {car_count}")
            print(f"Total plates detected: {plate_count}")
            print(f"Extracted plate texts: {plate_texts}")
            print(f"Total distance:        {cumulative_distance:.3f} m (Slot {final_slot})")
            print(f"Saved plate images ({len(plate_image_paths)}):")
            for p in plate_image_paths:
                print(f"  • {p}")
        else:
            print("[DEBUG] Main loop did not start due to earlier errors.")

if __name__ == '__main__':
    main()



model_inference.py

import cv2
import numpy as np
from pathlib import Path

class ModelInference:
    """Class to perform inference using car and number plate detection models."""
    
    def __init__(self, model_loader, conf_threshold=0.5, iou_threshold=0.45):
        """
        Initialize the ModelInference with a ModelLoader instance.
        
        Args:
            model_loader: Instance of ModelLoader with loaded ONNX models.
            conf_threshold (float): Confidence threshold for detections.
            iou_threshold (float): IoU threshold for Non-Maximum Suppression.
        """
        self.model_loader = model_loader
        self.conf_threshold = conf_threshold
        self.iou_threshold = iou_threshold
    
    def nms(self, boxes, scores, iou_threshold):
        """Apply Non-Maximum Suppression to filter overlapping bounding boxes.
        
        Args:
            boxes (np.ndarray): Array of bounding boxes [x1, y1, x2, y2].
            scores (np.ndarray): Confidence scores for each box.
            iou_threshold (float): IoU threshold for suppression.
        
        Returns:
            list: Indices of boxes to keep after NMS.
        """
        if len(boxes) == 0:
            return []
        x1, y1, x2, y2 = boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3]
        areas = (x2 - x1) * (y2 - y1)
        order = scores.argsort()[::-1]
        keep = []
        while order.size > 0:
            i = order[0]
            keep.append(i)
            xx1 = np.maximum(x1[i], x1[order[1:]])
            yy1 = np.maximum(y1[i], y1[order[1:]])
            xx2 = np.minimum(x2[i], x2[order[1:]])
            yy2 = np.minimum(y2[i], y2[order[1:]])
            w = np.maximum(0, xx2 - xx1)
            h = np.maximum(0, yy2 - yy1)
            inter = w * h
            iou = inter / (areas[i] + areas[order[1:]] - inter)
            inds = np.where(iou <= iou_threshold)[0]
            order = order[inds + 1]
        return keep
    
    def preprocess_image(self, img, input_size=(640, 640)):
        """Preprocess an image or frame for model inference.
        
        Args:
            img (np.ndarray): Input image or frame (BGR).
            input_size (tuple): Target size for resizing (width, height).
        
        Returns:
            tuple: (preprocessed image, original height, original width)
        """
        img_height, img_width = img.shape[:2]
        img_resized = cv2.resize(img, input_size)  # Resize to model input size
        img_resized = img_resized.transpose(2, 0, 1)  # HWC to CHW
        img_resized = img_resized[np.newaxis, ...] / 255.0  # Add batch dimension and normalize
        img_resized = img_resized.astype(np.float32)
        return img_resized, img_height, img_width
    
    def run_inference(self, session, input_name, img):
        """Run inference on a model session.
        
        Args:
            session: ONNX Runtime inference session.
            input_name (str): Name of the model input.
            img (np.ndarray): Preprocessed input image.
        
        Returns:
            np.ndarray: Model output.
        """
        return session.run(None, {input_name: img})[0]
    
    def postprocess_detections(self, outputs, img_height, img_width, num_classes):
        """Post-process model outputs to extract bounding boxes, scores, and class IDs.
        
        Args:
            outputs (np.ndarray): Model output [batch, num_boxes, num_classes + 5].
            img_height (int): Original image height.
            img_width (int): Original image width.
            num_classes (int): Number of classes in the model.
        
        Returns:
            tuple: (boxes, scores, class_ids)
        """
        boxes = []
        scores = []
        class_ids = []
        
        for detection in outputs[0]:  # Iterate over detections
            confidence = detection[4]  # Objectness score
            if confidence > self.conf_threshold:
                class_scores = detection[5:]  # Class probabilities
                class_id = np.argmax(class_scores)
                class_score = class_scores[class_id]
                if class_score * confidence > self.conf_threshold:
                    # Extract and scale bounding box
                    center_x, center_y, width, height = detection[0:4]
                    x1 = (center_x - width / 2) * img_width / 640
                    y1 = (center_y - height / 2) * img_height / 640
                    x2 = (center_x + width / 2) * img_width / 640
                    y2 = (center_y + height / 2) * img_height / 640
                    boxes.append([x1, y1, x2, y2])
                    scores.append(confidence * class_score)
                    class_ids.append(class_id)
        
        return np.array(boxes), np.array(scores), class_ids
    
    def infer_frame(self, frame):
        """Perform inference on a video frame using both car and number plate models.
        
        Args:
            frame (np.ndarray): Input frame (BGR).
        
        Returns:
            tuple: (car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids)
        """
        # Preprocess frame
        img, img_height, img_width = self.preprocess_image(frame, input_size=(640, 640))
        
        # Run car detection
        car_session = self.model_loader.get_car_session()
        car_input_name = self.model_loader.get_car_input_name()
        car_outputs = self.run_inference(car_session, car_input_name, img)
        car_num_classes = car_outputs.shape[2] - 5  # Infer number of classes
        car_boxes, car_scores, car_class_ids = self.postprocess_detections(
            car_outputs, img_height, img_width, car_num_classes
        )
        car_keep = self.nms(car_boxes, car_scores, self.iou_threshold) if len(car_boxes) > 0 else []
        car_boxes = car_boxes[car_keep]
        car_scores = car_scores[car_keep]
        car_class_ids = [car_class_ids[i] for i in car_keep]
        
        # Run number plate detection
        np_session = self.model_loader.get_np_session()
        np_input_name = self.model_loader.get_np_input_name()
        np_outputs = self.run_inference(np_session, np_input_name, img)
        np_num_classes = np_outputs.shape[2] - 5  # Infer number of classes
        np_boxes, np_scores, np_class_ids = self.postprocess_detections(
            np_outputs, img_height, img_width, np_num_classes
        )
        np_keep = self.nms(np_boxes, np_scores, self.iou_threshold) if len(np_boxes) > 0 else []
        np_boxes = np_boxes[np_keep]
        np_scores = np_scores[np_keep]
        np_class_ids = [np_class_ids[i] for i in np_keep]
        
        return car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids
    
    def infer(self, img_path, output_path):
        """Perform inference on an image using both car and number plate models.
        
        Args:
            img_path (str): Path to the input image.
            output_path (str): Path to save the output image with detections.
        
        Returns:
            tuple: (car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids)
        
        Raises:
            RuntimeError: If output image cannot be saved.
        """
        # Preprocess image
        img_orig = cv2.imread(str(img_path))
        if img_orig is None:
            raise FileNotFoundError(f"Could not load image: {img_path}")
        img, img_height, img_width = self.preprocess_image(img_orig)
        
        # Run car detection
        car_session = self.model_loader.get_car_session()
        car_input_name = self.model_loader.get_car_input_name()
        car_outputs = self.run_inference(car_session, car_input_name, img)
        car_num_classes = car_outputs.shape[2] - 5
        car_boxes, car_scores, car_class_ids = self.postprocess_detections(
            car_outputs, img_height, img_width, car_num_classes
        )
        car_keep = self.nms(car_boxes, car_scores, self.iou_threshold) if len(car_boxes) > 0 else []
        car_boxes = car_boxes[car_keep]
        car_scores = car_scores[car_keep]
        car_class_ids = [car_class_ids[i] for i in car_keep]
        
        # Run number plate detection
        np_session = self.model_loader.get_np_session()
        np_input_name = self.model_loader.get_np_input_name()
        np_outputs = self.run_inference(np_session, np_input_name, img)
        np_num_classes = np_outputs.shape[2] - 5
        np_boxes, np_scores, np_class_ids = self.postprocess_detections(
            np_outputs, img_height, img_width, np_num_classes
        )
        np_keep = self.nms(np_boxes, np_scores, self.iou_threshold) if len(np_boxes) > 0 else []
        np_boxes = np_boxes[np_keep]
        np_scores = np_scores[np_keep]
        np_class_ids = [np_class_ids[i] for i in np_keep]
        
        # Draw detections
        for i, box in enumerate(car_boxes):
            x1, y1, x2, y2 = box.astype(int)
            cv2.rectangle(img_orig, (x1, y1), (x2, y2), (0, 255, 0), 2)
            label = f"Car Class {car_class_ids[i]}: {car_scores[i]:.2f}"
            cv2.putText(img_orig, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
        for i, box in enumerate(np_boxes):
            x1, y1, x2, y2 = box.astype(int)
            cv2.rectangle(img_orig, (x1, y1), (x2, y2), (0, 255, 0), 2)
            label = f"NP Class {np_class_ids[i]}: {np_scores[i]:.2f}"
            cv2.putText(img_orig, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
        
        # Save output
        if not cv2.imwrite(str(output_path), img_orig):
            raise RuntimeError(f"Failed to save output image: {output_path}")
        print(f"Output saved as {output_path}")
        
        return car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids

if __name__ == "__main__":
    from model_loader import ModelLoader
    
    model_loader = ModelLoader(
        car_model_path="../models/car.onnx",
        np_model_path="../models//np.onnx"
    )
    inference = ModelInference(model_loader)
    car_boxes, car_scores, car_class_ids, np_boxes, np_scores, np_class_ids = inference.infer(
        img_path="../captured_images/car1.jpg",
        output_path="../captured_images/output.jpg"
    )
    print("Car detections:", len(car_boxes))
    print("Number plate detections:", len(np_boxes))



model_loader.py


import onnxruntime as ort
import os
from pathlib import Path
# hehe
class ModelLoader:
    """Class to load and manage ONNX models for car and number plate detection."""
    
    def __init__(self, car_model_path: str, np_model_path: str):
        """
        Initialize the ModelLoader with paths to car and number plate ONNX models.
        
        Args:
            car_model_path (str): Path to the car detection ONNX model.
            np_model_path (str): Path to the number plate detection ONNX model.
        
        Raises:
            FileNotFoundError: If model files do not exist.
            RuntimeError: If model loading fails.
        """
        # Validate model paths
        self.car_model_path = Path(car_model_path)
        self.np_model_path = Path(np_model_path)
        
        if not self.car_model_path.exists():
            raise FileNotFoundError(f"Car model file not found: {self.car_model_path}")
        if not self.np_model_path.exists():
            raise FileNotFoundError(f"Number plate model file not found: {self.np_model_path}")
        
        # Initialize inference sessions
        self.car_session = None
        self.np_session = None
        self._load_models()
    
    def _load_models(self):
        """Load the ONNX models into inference sessions."""
        try:
            self.car_session = ort.InferenceSession(str(self.car_model_path))
            print(f"Successfully loaded car detection model: {self.car_model_path}")
        except Exception as e:
            raise RuntimeError(f"Failed to load car detection model: {str(e)}")
        
        try:
            self.np_session = ort.InferenceSession(str(self.np_model_path))
            print(f"Successfully loaded number plate detection model: {self.np_model_path}")
        except Exception as e:
            raise RuntimeError(f"Failed to load number plate detection model: {str(e)}")
    
    def get_car_session(self):
        """
        Get the car detection model inference session.
        
        Returns:
            ort.InferenceSession: The car detection model session.
        """
        return self.car_session
    
    def get_np_session(self):
        """
        Get the number plate detection model inference session.
        
        Returns:
            ort.InferenceSession: The number plate detection model session.
        """
        return self.np_session
    
    def get_car_input_name(self):
        """
        Get the input name for the car detection model.
        
        Returns:
            str: The input name for the car detection model.
        """
        return self.car_session.get_inputs()[0].name
    
    def get_np_input_name(self):
        """
        Get the input name for the number plate detection model.
        
        Returns:
            str: The input name for the number plate detection model.
        """
        return self.np_session.get_inputs()[0].name

if __name__ == "__main__":
    # Example usage for testing
    model_loader = ModelLoader(
        car_model_path="../models/car.onnx",
        np_model_path="../models//np.onnx"
    )
    print("Car model input name:", model_loader.get_car_input_name())
    print("Number plate model input name:", model_loader.get_np_input_name())


database.py

from pymongo import MongoClient
from pymongo.errors import ConnectionFailure
from datetime import datetime
import sys

class Database:
    def __init__(self, mongo_uri="mongodb+srv://akshayareddy:akshaya20@clusterprac.w63oe.mongodb.net/?retryWrites=true&w=majority&appName=Clusterprac", 
                 db_name="parksense", car_logs_collection="car_logs", visitors_collection="visitors", rover_logs_collection="rover_logs"):
        try:
            self.client = MongoClient(mongo_uri, serverSelectionTimeoutMS=5000)
            self.db = self.client[db_name]
            self.car_logs = self.db[car_logs_collection]
            self.visitors = self.db[visitors_collection]
            self.rover_logs = self.db[rover_logs_collection]
            self.client.admin.command('ping')
            print("MongoDB Atlas connection successful!")
        except ConnectionFailure as e:
            print(f"MongoDB Atlas connection failed! Error: {e}")
            print("Please check the connection string, network, or MongoDB Atlas status.")
            sys.exit(1)
        except Exception as e:
            print(f"Unexpected error during MongoDB connection: {e}")
            sys.exit(1)

    def upsert_number_plate(self, number_plate, slot):
        try:
            result = self.car_logs.update_one(
                {"number_plate": number_plate},
                {
                    "$set": {
                        "timestamp": datetime.utcnow(),
                        "number_plate": number_plate,
                        "slots": slot
                    }
                },
                upsert=True
            )
            if result.matched_count > 0:
                print(f"Updated plate: {number_plate} in slot {slot}")
            else:
                print(f"Inserted new number plate: {number_plate} with slot {slot}")
            return True
        except Exception as e:
            print(f"Failed to upsert number plate {number_plate}: {e}")
            return False

    def check_number_plate(self, number_plate):
        try:
            return self.car_logs.find_one({"number_plate": number_plate}) is not None
        except Exception as e:
            print(f"Failed to check number plate {number_plate}: {e}")
            return False

    def log_car_entry(self, number_plate, slot):
        try:
            visitor_entry = self.visitors.find_one({
                'car_number': number_plate,
                'exit_time': {'$exists': False}
            })
            status = 'authorized' if visitor_entry else 'unauthorized'
            
            existing_log = self.car_logs.find_one({
                'number_plate': number_plate,
                'slots': slot,
                'status': {'$in': ['authorized', 'unauthorized']}
            })

            if existing_log:
                print(f"Car {number_plate} already logged in slot {slot}. Skipping...")
                return
            
            log_entry = {
                'timestamp': datetime.utcnow(),
                'number_plate': number_plate,
                'slots': slot,
                'status': status
            }
            self.car_logs.insert_one(log_entry)
            print(f"Car {number_plate} logged as {status} in slot {slot}.")
        except Exception as e:
            print(f"Failed to log car entry for {number_plate}: {e}")

    def insert_telemetry(self, data):
        try:
            # Update the single telemetry document and increment trip_count
            result = self.rover_logs.update_one(
                {"_id": "telemetry"},
                {
                    "$set": {
                        "timestamp": datetime.utcnow(),
                        "gps": data["gps"],
                        "battery": data["battery"],
                        "heading": data["heading"],
                        "velocity": data["velocity"],
                        "mode": data["mode"],
                        "armed": data["armed"],
                        "system_status": data["system_status"]
                    },
                    "$inc": {"trip_count": 1}  # Increment trip_count
                },
                upsert=True
            )
            if result.matched_count > 0:
                print("Updated telemetry document")
            else:
                print("Created new telemetry document")
                # Ensure trip_count is initialized if document is created
                self.rover_logs.update_one(
                    {"_id": "telemetry"},
                    {"$setOnInsert": {"trip_count": 0}},
                    upsert=True
                )
            return True
        except Exception as e:
            print(f"Failed to update telemetry data: {e}")
            return False

    def close(self):
        try:
            self.client.close()
            print("MongoDB connection closed.")
        except Exception as e:
            print(f"Error closing MongoDB connection: {e}")


yaw.py


import math

# Constants from rover.py
CENTER = 1500
TURN_AMOUNT = 90
MIN_STEERING = 1000
MAX_STEERING = 2000

def get_yaw(vehicle):
    """
    Retrieves the current yaw from the vehicle in degrees.
    Returns None if yaw is unavailable.
    """
    try:
        return math.degrees(vehicle.attitude.yaw)
    except AttributeError:
        print("Warning: Could not retrieve attitude information.")
        return None

def adjust_steering_for_yaw(vehicle, initial_yaw, drift_threshold, yaw_buffer=None):
    """
    Calculates steering to correct yaw deviation based on threshold.
    Returns steering value (PWM) using the exact logic from rover.py.
    Note: yaw_buffer is included for compatibility but not used.
    """
    yaw = get_yaw(vehicle)
    if yaw is None or initial_yaw is None:
        return CENTER

    yaw_deviation = yaw - initial_yaw
    # Normalize the angle difference to be within -180 to 180 degrees
    if yaw_deviation > 180:
        yaw_deviation -= 360
    elif yaw_deviation < -180:
        yaw_deviation += 360

    if yaw_deviation > drift_threshold:  # Drifting right, correct left
        steering = max(CENTER - TURN_AMOUNT, MIN_STEERING)
    elif yaw_deviation < -drift_threshold:  # Drifting left, correct right
        steering = min(CENTER + TURN_AMOUNT, MAX_STEERING)
    else:
        steering = CENTER

    return int(steering)
